<?xml version="1.0"  encoding="UTF-8" ?>
<bindings xmlns="http://www.mozilla.org/xbl"
        xmlns:xbl="http://www.mozilla.org/xbl"
        xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

    <!-- Binding around a browser that is used to load a web page -->
    <binding id="slimer_navigator">
        <content flex="1">
            <xul:browser anonid="mBrowser" flex="1"
                         type="content-targetable" autoscroll="true" disablesecurity="false"/>
        </content>
        <implementation>
            <constructor>
                <![CDATA[
                //this.browser.addProgressListener(this.mProgressListener, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
                this.initMessageManager();
                this.browser.messageManager.loadFrameScript('chrome://slimerjs/content/navigatorFrameScript.js', true);
                this._sendReadyEvent();
            ]]>
            </constructor>
            <destructor>
                this.resetBrowser();
            </destructor>

            <field name="browser" readonly="true">
                document.getAnonymousElementByAttribute(this, "anonid", "mBrowser");
            </field>

            <field name="onpageloaded">null</field>
            
            <method name="resetBrowser">
                <body>
                    this.onpageloaded = null;
                    this.browser.stop();
                    //this.browser.removeProgressListener(this.mProgressListener);
                    //this.browser.sessionHistory.PurgeHistory(1000);
                    this.browser.destroy();
                </body>
            </method>

            <method name="_sendReadyEvent">
                <body>
                    // before touching browser, we should wait that it is initialized,
                    // however we don't have a simple way to know when it is finished
                    // so let's trigger a timeout :-/ #uglyhack
                    var me = this;
                    window.setTimeout(function() {
                        var evt = document.createEvent("Event");
                        evt.initEvent("BrowserReady", true, false);
                        me.dispatchEvent(evt);
                    }, 100);
                </body>
            </method>

            <method name="initMessageManager">
                <body><![CDATA[
                var me = this;
                var mm = this.browser.messageManager;

                mm.addMessageListener("pageloaded", function(message){
                    let channel = me.browser.docShell.currentDocumentChannel
                    try {
                        channel = channel.QueryInterface(Components.interfaces.nsIHttpChannel);
                    }
                    catch(e){}
                    let success = "success";
                    if (channel) {
                        success = channel.requestSucceeded?"success":"fail";
                    }

                    if (me.onpageloaded)
                        me.onpageloaded(success);
                });
                ]]></body>
            </method>

            <field name="mProgressListener">
                <![CDATA[
                    {
                        QueryInterface : function(aIID)
                        {
                          if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||
                              aIID.equals(Components.interfaces.nsIWebProgressListener2) ||
                              aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
                              aIID.equals(Components.interfaces.nsISupports))
                            return this;
                          throw Components.results.NS_NOINTERFACE;
                        },

                        onProgressChange : function (aWebProgress, aRequest,
                                aCurSelfProgress, aMaxSelfProgress,
                                aCurTotalProgress, aMaxTotalProgress)
                        {

                        },

                        onProgressChange64 : function (aWebProgress, aRequest,
                                aCurSelfProgress, aMaxSelfProgress,
                                aCurTotalProgress, aMaxTotalProgress)
                        {

                        },

                        onStateChange : function(aWebProgress, aRequest, aStateFlags, aStatus)
                        {
                            if (aWebProgress.isLoadingDocument==true)
                            {
                            }
                            else
                            {
                            }

                            const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
                            if (aStateFlags & nsIWebProgressListener.STATE_START)
                            {
                            }
                            else if (aStateFlags & nsIWebProgressListener.STATE_STOP)
                            {
                            }
                        },

                        onLocationChange : function(aWebProgress, aRequest, aLocation)
                        {
                        },

                        onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage)
                        {
                        },

                        onSecurityChange : function(aWebProgress, aRequest, aState)
                        {

                        },

                        onRefreshAttempted : function(aWebProgress, aURI, aDelay, aSameURI)
                        {
                        }
                    }
                ]]>
            </field>

            <method name="evaluate">
                <parameter name="script" />
                <parameter name="args" />
                <body><![CDATA[
                // FIXME: should the sandbox be created each time or only after the page is loaded?
                let sandbox = Components.utils.Sandbox(this.browser.contentWindow,
                            {
                                'sandboxName': this.browser.currentURI.spec,
                                'sandboxPrototype': this.browser.contentWindow,
                                'wantXrays': true
                            });
                sandbox.__slimer_args = Array.isArray(args)?args:[args];
                script = '('+script.toSource()+').apply(null, __slimer_args);}';
                return Components.utils.evalInSandbox(script, sandbox);
                ]]></body>
            </method>

            <method name="evaluateAsync">
                <parameter name="script" />
                <body><![CDATA[
                // FIXME: should the sandbox be created each time or only after the page is loaded?
                let sandbox = Components.utils.Sandbox(this.browser.contentWindow,
                            {
                                'sandboxName': this.browser.currentURI.spec,
                                'sandboxPrototype': this.browser.contentWindow,
                                'wantXrays': true
                            });
                script = '('+script.toSource()+')();';
                window.setTimeout(function() {
                    Components.utils.evalInSandbox(script, sandbox);
                }, 0)
                ]]></body>
            </method>

        </implementation>
        <handlers>
        </handlers>
    </binding>
</bindings>


